<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. 实验目的 &mdash; 计算机网络实验指导书 - 2022春季 | 哈工大（深圳） v1.0 文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/my_style.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
        <script src="../_static/js/baidu-tongji.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="Lab4：RIP路由配置及协议分析" href="../lab8/index.html" />
    <link rel="prev" title="Lab3：协议栈之ARP协议实现" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> 计算机网络实验指导书 - 2022春季 | 哈工大（深圳）
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">实验</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../lab0/index.html">计算机网络实验概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lab4/index.html">Lab1：VLAN 与接口模式配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lab2/index.html">Lab2：协议栈之Eth协议实现</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Lab3：协议栈之ARP协议实现</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">1. 实验目的</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">2. 实验任务</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">3. 实验原理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#arp">3.1. ARP协议概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">3.2. ARP的工作机制</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">3.2.1. 同一网段的ARP解析过程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">3.2.2. 不同网段的ARP解析过程</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">3.3. ARP协议报文格式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">3.4. ARP表</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id9">4. 代码实现与检测</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">4.1. ARP初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">4.2. ARP发送处理过程</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">4.3. ARP接收处理过程</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">4.4. ARP响应包</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">4.5. 实验自测</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id15">5. 实验提交</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../lab8/index.html">Lab4：RIP路由配置及协议分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lab5/index.html">Lab5：协议栈之IP协议实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lab6/index.html">Lab6：协议栈之ICMP协议实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lab7/index.html">Lab7：协议栈之UDP协议实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lab10/index.html">Lab8：NAT组网</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lab9/index.html">Lab9：邮件客户端的设计与实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proplus/index.html">附加题</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">附录</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix-a/index.html">附录 A：Wireshark 入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-b/index.html">附录 B：网络编程实验环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-c/index.html">附录 C：Cisco Packet Tracer简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-d/index.html">附录 D：参考文献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-e/index.html">附录 E：致谢</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">计算机网络实验指导书 - 2022春季 | 哈工大（深圳）</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Lab3：协议栈之ARP协议实现</a> &raquo;</li>
      <li><span class="section-number">1. </span>实验目的</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/lab3/0intro.rst.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1><span class="section-number">1. </span>实验目的<a class="headerlink" href="#id1" title="永久链接至标题"></a></h1>
<ol class="arabic simple">
<li><p>熟悉ARP数据包格式，掌握ARP映射表的建立与更新过程；</p></li>
<li><p>掌握ARP数据包的的发送和接收处理过程。</p></li>
</ol>
</section>
<section id="id2">
<h1><span class="section-number">2. </span>实验任务<a class="headerlink" href="#id2" title="永久链接至标题"></a></h1>
<p>在完成协议栈之eth协议的基础上，编写ARP报文的接收、发送和请求报文函数，使其能够发送和接收ARP数据报文，并且能通过实验评测系统的测试。</p>
</section>
<section id="id3">
<h1><span class="section-number">3. </span>实验原理<a class="headerlink" href="#id3" title="永久链接至标题"></a></h1>
<section id="arp">
<h2><span class="section-number">3.1. </span>ARP协议概要<a class="headerlink" href="#arp" title="永久链接至标题"></a></h2>
<p>在TCP/IP的网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要确定了IP地址，就可向这个目标地址发送IP数据报了。然而，在数据链路层使用的是硬件地址（MAC）进行报文传输，IP地址不能被物理网络所识别，因此必须建立IP地址和MAC地址的映射关系，这一过程称为ARP（Address Resolution Protocol）地址解析协议。</p>
<p>ARP协议以目标IP地址为线索，用来定位下一个应该接收数据包的网络设备对应的MAC地址。如果目标主机不在同一个链路上，可以通过ARP查找下一跳网关的MAC地址。注意，ARP只适用于IPv4，不能用于IPv6。IPv6可以用ICMPv6替代ARP发送邻居探索消息。</p>
</section>
<section id="id4">
<h2><span class="section-number">3.2. </span>ARP的工作机制<a class="headerlink" href="#id4" title="永久链接至标题"></a></h2>
<p>那么ARP又是如何知道MAC地址的呢？简单地说，ARP是借助ARP请求与ARP响应两种类型的包确定MAC地址的。此外，在每台使用ARP的主机中，都保留了一个专用的内存区（称为缓存），存放最近的IP地址与硬件地址的对应关系。一旦收到ARP应答，主机将获得的IP地址和硬件地址的对应关系存到缓存中。当发送报文时，首先去缓存中查找相应的项，如果找到相应项，便将报文直接发送出去；如果找不到，再利用ARP进行解析。ARP 缓存信息在一定时间内有效，过期不更新就会被删除。</p>
<section id="id5">
<h3><span class="section-number">3.2.1. </span>同一网段的ARP解析过程<a class="headerlink" href="#id5" title="永久链接至标题"></a></h3>
<p>如下图所示，主机A需要发报文给主机B，如果在缓存中找不到相应的记录，就必须先解析主机B的硬件地址。主机A首先在网段内通过广播发出ARP请求报文，由于广播的包可以被同一个链路上所有的主机或路由器接收，因此ARP的请求包也就会被这同一个链路上所有的主机和路由器进行解析。主机B收到后，判断报文的目的IP是本主机的IP地址，便将本主机的硬件地址写入应答报文，发送给主机A，主机A收到后将其存入缓存中，则解析成功，然后才将报文发往主机B。</p>
<img alt="../_images/同一网段ARP.png" src="../_images/同一网段ARP.png" />
</section>
<section id="id6">
<h3><span class="section-number">3.2.2. </span>不同网段的ARP解析过程<a class="headerlink" href="#id6" title="永久链接至标题"></a></h3>
<p>如下图所示，主机A要发报文给主机C，首先主机A分析目的地址不在同一个网段，需要将报文先发给其默认网关，再由默认网关转发。如果没有找到默认网关的硬件地址，便发送ARP请求报文，请求默认网关的硬件地址，默认网关收到之后，将自己的硬件地址写入应答报文，发送给主机A。然后，主机A到主机C的报文首先被送到默认网关。默认网关再根据报文的目的IP地址进行转发，以此类推，直至报文送到主机C中。主机C到主机A的报文以相反的顺序发送。</p>
<img alt="../_images/不同网段ARP.png" src="../_images/不同网段ARP.png" />
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>请思考，IP地址和MAC地址为什么缺一不可？</p>
</div>
</section>
</section>
<section id="id7">
<h2><span class="section-number">3.3. </span>ARP协议报文格式<a class="headerlink" href="#id7" title="永久链接至标题"></a></h2>
<p>ARP是一个独立的三层协议，所以ARP报文在向数据链路层传输时不需要经过IP协议的封装，而是直接生成自己的报文，其中包括ARP报头，到数据链路层后再对应的数据链路层（如以太网协议）进行封装。ARP报文分为ARP请求和应答报文两种，报文格式如下图所示。</p>
<img alt="../_images/ARP.png" src="../_images/ARP.png" />
<p>ARP报文每个字段的含义如下表所示：</p>
<ul class="simple">
<li><p><strong>硬件类型</strong> ：占2字节，表示ARP报文可以在哪种类型的网络上传输，值为1时表示为以太网地址。</p></li>
<li><p><strong>上层协议类型</strong> ：占2字节，表示硬件地址要映射的协议地址类型，映射IP地址时的值为0x0800。</p></li>
<li><p><strong>MAC地址长度</strong> ： 占1字节，标识MAC地址长度，以字节为单位，此处为6。</p></li>
<li><p><strong>IP协议地址长度</strong> ： 占1字节，标识IP地址长度，以字节为单位，此处为4。</p></li>
<li><p><strong>操作类型</strong> ： 占2字节，指定本次ARP报文类型。1标识ARP请求报文，2标识ARP应答报文。</p></li>
<li><p><strong>源MAC地址</strong> ： 占6字节，标识发送设备的硬件地址。</p></li>
<li><p><strong>源IP地址</strong> ： 占4字节，标识发送方设备的IP地址。</p></li>
<li><p><strong>目的MAC地址</strong> ： 占6字节，表示接收方设备的硬件地址，在请求报文中该字段值全为0，即00-00-00-00-00-00，表示任意地址，因为现在不知道这个MAC地址。</p></li>
<li><p><strong>目的IP地址</strong> ： 占4字节，表示接受方的IP地址。</p></li>
</ul>
</section>
<section id="id8">
<h2><span class="section-number">3.4. </span>ARP表<a class="headerlink" href="#id8" title="永久链接至标题"></a></h2>
<p>无论是主机，还是交换机或路由器都会有一个用来缓存同一网段设备IP地址和MAC地址的ARP映射表，用于数据帧的转发。设备通过ARP解析到目的MAC之后，将会在自己的ARP映射表中增加IP地址到MAC地址的映射表，以用于后续到同一目的地数据帧的转发。ARP表项分为动态ARP表项和静态ARP表项。在实验中，我们需要实现 <strong>动态ARP表项</strong> 。</p>
<p>动态ARP表项由ARP协议通过ARP报文自动生成和维护，可以被老化，可以被新的ARP报文更新，也可以被静态ARP表项所覆盖。当到达老化时间或接口关闭时会删除相应的动态ARP表项。</p>
<p>在本实验中，我们提供了支持超时时间的map键值对容器框架，以减轻同学们的部分工作量：）。在用于获取map中指定键的值map_set()函数中，调用map_entry_valid()函数判断该键值对是否有效，而判断的标准里就有是否超时判断。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w">   </span><span class="cm">/**</span>
<span class="linenos"> 2</span><span class="cm">   * @brief 内部函数，判断键值对是否有效</span>
<span class="linenos"> 3</span><span class="cm">   *</span>
<span class="linenos"> 4</span><span class="cm">   * @param map 要判断的map</span>
<span class="linenos"> 5</span><span class="cm">   * @param entry 键值对指针</span>
<span class="linenos"> 6</span><span class="cm">   * @return int 1为合法，0为不合法</span>
<span class="linenos"> 7</span><span class="cm">   */</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="nf">map_entry_valid</span><span class="p">(</span><span class="n">map_t</span><span class="w"> </span><span class="o">*</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">entry</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">10</span><span class="w">      </span><span class="kt">time_t</span><span class="w"> </span><span class="n">entry_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">time_t</span><span class="w"> </span><span class="o">*</span><span class="p">)((</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">entry</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">map</span><span class="o">-&gt;</span><span class="n">key_len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">map</span><span class="o">-&gt;</span><span class="n">value_len</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">entry_time</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">entry_time</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">map</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span><span class="w"></span>
<span class="linenos">12</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">   </span><span class="cm">/**</span>
<span class="linenos">15</span><span class="cm">   * @brief 获取map中指定键的值</span>
<span class="linenos">16</span><span class="cm">   *</span>
<span class="linenos">17</span><span class="cm">   * @param map 要获取的map</span>
<span class="linenos">18</span><span class="cm">   * @param key 键指针</span>
<span class="linenos">19</span><span class="cm">   * @return void* 值指针，找不到为NULL</span>
<span class="linenos">20</span><span class="cm">   */</span><span class="w"></span>
<span class="linenos">21</span><span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">map_get</span><span class="p">(</span><span class="n">map_t</span><span class="w"> </span><span class="o">*</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">)</span><span class="w"></span>
<span class="linenos">22</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">23</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="linenos">24</span><span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="linenos">25</span><span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">map</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="linenos">26</span><span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="linenos">27</span><span class="w">         </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_entry_get</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="linenos">28</span><span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">map_entry_valid</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="n">entry</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">entry</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="o">-&gt;</span><span class="n">key_len</span><span class="p">))</span><span class="w"></span>
<span class="linenos">29</span><span class="w">               </span><span class="k">return</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">map</span><span class="o">-&gt;</span><span class="n">key_len</span><span class="p">;</span><span class="w"></span>
<span class="linenos">30</span><span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="linenos">31</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="linenos">32</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="id9">
<h1><span class="section-number">4. </span>代码实现与检测<a class="headerlink" href="#id9" title="永久链接至标题"></a></h1>
<p>请同学们认真阅读本实验提供的代码框架，并补充完整 src/arp.c 文件中的arp_req()函数、arp_out()函数和arp_in()函数。</p>
<section id="id10">
<h2><span class="section-number">4.1. </span>ARP初始化<a class="headerlink" href="#id10" title="永久链接至标题"></a></h2>
<p>arp_init()函数实现ARP初始化功能，初始化流程如下：</p>
<p><strong>1</strong> ：调用map_init()函数，初始化用于存储IP地址和MAC地址的ARP表arp_table，并设置超时时间为ARP_TIMEOUT_SEC。</p>
<p><strong>2</strong> ：调用map_init()函数，初始化用于缓存来自IP层的数据包，并设置超时时间为ARP_MIN_INTERVAL。</p>
<p><strong>3</strong> ：调用net_add_protocol()函数，增加key：NET_PROTOCOL_ARP和vaule：arp_in的键值对。</p>
<p><strong>4</strong> ：在初始化阶段（系统启用网卡）时，要向网络上发送无回报ARP包（ARP announcemennt），即广播包，告诉所有人自己的IP地址和MAC地址。在实验代码中，调用arp_req()函数来发送一个无回报ARP包。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p><strong>无回报ARP包（ARP announcement）</strong> ：用于昭示天下（LAN）本机要使用某个IP地址了，是一个Sender IP和Traget IP填充的都是本机IP地址的ARP request。</p>
</div>
<p>同学们需要自行实现arp_req()函数，功能如下：</p>
<p><strong>Step1</strong> ：调用buf_init()对txbuf进行初始化。</p>
<p><strong>Step2</strong> ：填写ARP报头。</p>
<p><strong>Step3</strong> ：ARP操作类型为ARP_REQUEST，注意大小端转换。</p>
<p><strong>Step4</strong> ：调用ethernet_out函数将ARP报文发送出去。</p>
</section>
<section id="id11">
<h2><span class="section-number">4.2. </span>ARP发送处理过程<a class="headerlink" href="#id11" title="永久链接至标题"></a></h2>
<p>同学们需要自行实现arp_out()函数，功能如下：</p>
<p><strong>Step1</strong> ：根据IP地址来查找ARP表(arp_table)。</p>
<p><strong>Step2</strong> ：如果能找到该IP地址对应的MAC地址，则将数据包直接发送给以太网层，即调用ethernet_out函数直接发出去。</p>
<p><strong>Step3</strong> ：如果没有找到对应的MAC地址，进一步判断arp_buf是否已经有包了，如果有，则说明正在等待该ip回应ARP请求，此时不能再发送arp请求，否则会造成广播风暴；如果没有包，则调用map_set()函数将来自IP层的数据包缓存到arp_buf，然后，调用arp_req()函数，发一个请求目标IP地址对应的MAC地址的ARP request报文。</p>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>由于map数据结构的限制，相同ip的arp_buf长度仍为1，同学们可以自行设计数据结构实现不丢包。</p>
</div>
</section>
<section id="id12">
<h2><span class="section-number">4.3. </span>ARP接收处理过程<a class="headerlink" href="#id12" title="永久链接至标题"></a></h2>
<p>同学们需要自行实现arp_in()函数，功能如下：</p>
<p><strong>Step1</strong> ：首先判断数据长度，如果数据长度小于ARP头部长度，则认为数据包不完整，丢弃不处理。</p>
<p><strong>Step2</strong> ：接着，做报头检查，查看报文是否完整，检测内容包括：ARP报头的硬件类型、上层协议类型、MAC硬件地址长度、IP协议地址长度、操作类型，检测这些内存是否符合协议规定。</p>
<p><strong>Step3</strong> ：调用map_set()函数更新ARP表项。</p>
<p><strong>Step4</strong> ：调用map_get()函数查看该接收报文的IP地址是否有对应的arp_buf缓存。</p>
<p>如果有，则说明ARP分组队列里面有待发送的数据包。也就是上一次调用arp_out()函数发送来自IP层的数据包时，由于没有找到对应的MAC地址进而先发送的ARP request报文，此时收到了该request的应答报文。然后，将缓存的数据包arp_buf再发送给以太网层，即调用ethernet_out()函数直接发出去，接着调用map_delete()函数将这个缓存的数据包删除掉。</p>
<p>如果该接收报文的IP地址没有对应的arp_buf缓存，还需要判断接收到的报文是否为ARP_REQUEST请求报文，并且该请求报文的target_ip是本机的IP，则认为是请求本主机MAC地址的ARP请求报文，则调用arp_resp()函数回应一个响应报文。</p>
</section>
<section id="id13">
<h2><span class="section-number">4.4. </span>ARP响应包<a class="headerlink" href="#id13" title="永久链接至标题"></a></h2>
<p>同学们需要自行实现arp_resp()，功能如下：</p>
<p><strong>Step1</strong> ：首先调用buf_init()来初始化txbuf。</p>
<p><strong>Step2</strong> ：接着，填写ARP报头首部。</p>
<p><strong>Step3</strong> ：调用ethernet_out()函数将填充好的ARP报文发送出去。</p>
</section>
<section id="id14">
<h2><span class="section-number">4.5. </span>实验自测<a class="headerlink" href="#id14" title="永久链接至标题"></a></h2>
<p>ARP自测与eth自测的步骤类似。</p>
<p>点击CMake工具栏，找到arp_test[arp_test.exe]，右键，选择“生成”进行编译。</p>
<a class="reference internal image-reference" href="../_images/cmake7.png"><img alt="../_images/cmake7.png" src="../_images/cmake7.png" style="height: 500px;" /></a>
<p>接着，打开VSCode的终端，到build目录下，输入ctest -R arp_test进行自测。</p>
<p>ARP协议自测，处理正确的结果显示如下图：</p>
<img alt="../_images/cmake12.png" src="../_images/cmake12.png" />
<p>如果提示有错，请参照eth协议自测的排除方法来找bug。</p>
</section>
</section>
<section id="id15">
<h1><span class="section-number">5. </span>实验提交<a class="headerlink" href="#id15" title="永久链接至标题"></a></h1>
<p>请参考实验一的提交方式。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Lab3：协议栈之ARP协议实现" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../lab8/index.html" class="btn btn-neutral float-right" title="Lab4：RIP路由配置及协议分析" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022, qiu.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>